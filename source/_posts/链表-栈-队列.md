---
title: '链表,栈,队列'
date: 2022-02-14 18:38:41
tags: [链表,栈,队列]
categories: 数据结构
---

## 链表

-------

* 单链表：模拟邻接表，存储树和图
* 双链表：优化

### 链式向前星

铉杰教的~(手动@)，这个方法真的very nice 用数组模拟链表

推荐大家试一试

### 例题：

#### 单链表：

> 实现一个单链表，链表初始为空，支持三种操作：
>
> 1. 向链表头插入一个数；
> 2. 删除第 k 个插入的数后面的数；
> 3. 在第 k 个插入的数后插入一个数。
>
> 现在要对该链表进行 M 次操作，进行完所有操作后，从头到尾输出整个链表。
>
> **注意**:题目中第 k 个插入的数并不是指当前链表的第 k 个数。例如操作过程中一共插入了 n 个数，则按照插入的时间顺序，这 n 个数依次为：第 1 个插入的数，第 2 个插入的数，…第 n 个插入的数。
>
> #### 输入格式
>
> 第一行包含整数 M，表示操作次数。
>
> 接下来 M 行，每行包含一个操作命令，操作命令可能为以下几种：
>
> 1. `H x`，表示向链表头插入一个 x。
> 2. `D k`，表示删除第 k 个插入的数后面的数（当 k 为 0 时，表示删除头结点）。
> 3. `I k x`，表示在第 k 个插入的数后面插入一个数 x（此操作中 k 均大于 0）。
>
> #### 输出格式
>
> 共一行，将整个链表从头到尾输出。
>
> #### 数据范围
>
> 1≤M≤100000
> 所有操作保证合法。
>
> #### 输入样例：
>
> ```
> 10
> H 9
> I 1 1
> D 1
> D 0
> H 6
> I 3 6
> I 4 5
> I 4 5
> I 3 4
> D 6
> ```
>
> #### 输出样例：
>
> ```
> 6 4 6 5
> ```

```java
import java.util.Scanner;

public class Main {
    static int N = (int)1e5 + 10;
    static int head,idx;
    static int ne[] = new int[N];
    static int e[] = new int[N];
    static int n;
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        init();
        n = sc.nextInt();
        while (n -- != 0){
            int k,x;
            char op = sc.next().charAt(0);
            if (op == 'H'){
                x = sc.nextInt();
                add_head(x);
            }
            else if (op == 'D'){
                k = sc.nextInt();
                if (k == 0) {
                    head = ne[head];
                }
                else del(k - 1);
            }
            else {
                k = sc.nextInt();
                x = sc.nextInt();
                add(k - 1,x);
            }

        }
        for (int i = head; i != -1 ; i = ne[i]) {
            System.out.print(e[i] + " ");
        }
        sc.close();
    }
    public static void init(){
        idx = 0;
        head = -1;
    }
    public static void add_head(int x){
        e[idx] = x;
        ne[idx] = head;
        head = idx ++;
    }
    public static void add(int k,int x){
        e[idx] = x;
        ne[idx] = ne[k];
        ne[k] = idx ++;
    }
    public static void del(int k){
        ne[k] = ne[ne[k]];
    }
}
```

-------

#### 双链表：

> 实现一个双链表，双链表初始为空，支持 5 种操作：
>
> 1. 在最左侧插入一个数；
> 2. 在最右侧插入一个数；
> 3. 将第 k 个插入的数删除；
> 4. 在第 k 个插入的数左侧插入一个数；
> 5. 在第 k 个插入的数右侧插入一个数
>
> 现在要对该链表进行 M 次操作，进行完所有操作后，从左到右输出整个链表。
>
> **注意**:题目中第 k 个插入的数并不是指当前链表的第 k 个数。例如操作过程中一共插入了 n 个数，则按照插入的时间顺序，这 n 个数依次为：第 1 个插入的数，第 2 个插入的数，…第 n 个插入的数。
>
> #### 输入格式
>
> 第一行包含整数 M，表示操作次数。
>
> 接下来 M 行，每行包含一个操作命令，操作命令可能为以下几种：
>
> 1. `L x`，表示在链表的最左端插入数 x。
> 2. `R x`，表示在链表的最右端插入数 x。
> 3. `D k`，表示将第 k 个插入的数删除。
> 4. `IL k x`，表示在第 k 个插入的数左侧插入一个数。
> 5. `IR k x`，表示在第 k 个插入的数右侧插入一个数。
>
> #### 输出格式
>
> 共一行，将整个链表从左到右输出。
>
> #### 数据范围
>
> 1≤M≤100000
> 所有操作保证合法。
>
> #### 输入样例：
>
> ```
> 10
> R 7
> D 1
> L 3
> IL 2 10
> D 3
> IL 2 7
> L 8
> R 9
> IL 4 7
> IR 2 2
> ```
>
> #### 输出样例：
>
> ```
> 8 7 7 3 2 9
> ```

```java
import java.util.Scanner;

public class Main {
    static int N = (int)1e5 + 10;
    static int m;
    static int e[] = new int[N];
    static int l[] = new int[N];
    static int r[] = new int[N];
    static int idx;
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        m = sc.nextInt();
        init();
        while (m -- != 0){
            String op = sc.next();
            int k,x;
            if (op.equals("L")){
                x = sc.nextInt();
                insert(0,x);
            }
            else if (op.equals("R")){
                x = sc.nextInt();
                insert(l[1],x);
            }
            else if (op.equals("D")){
                k = sc.nextInt();
                remove(k + 1);
            }
            else if (op.equals("IL")){
                k = sc.nextInt();
                x = sc.nextInt();
                insert(l[k + 1],x);
            }
            else {
                k = sc.nextInt();
                x = sc.nextInt();
                insert(k + 1,x);
            }
        }
        for (int i = r[0]; i != 1; i = r[i]) {
            System.out.print(e[i] + " ");
        }
        sc.close();
    }
    public static void init(){
        r[0] = 1;
        l[1] = 0;
        idx = 2;
    }
    public static void insert(int a,int x){
        e[idx] = x;
        l[idx] = a;r[idx] = r[a];
        l[r[a]] = idx;r[a] = idx ++;
    }
    public static void remove(int a){
        l[r[a]] = l[a];
        r[l[a]] = r[a];
    }
}
```

-------

## 栈和队列

------

### 普通的栈和队列

### 例题：

#### 栈：

> 实现一个栈，栈初始为空，支持四种操作：
>
> 1. `push x` – 向栈顶插入一个数 x；
> 2. `pop` – 从栈顶弹出一个数；
> 3. `empty` – 判断栈是否为空；
> 4. `query` – 查询栈顶元素。
>
> 现在要对栈进行 MM 个操作，其中的每个操作 33 和操作 44 都要输出相应的结果。
>
> #### 输入格式
>
> 第一行包含整数 M，表示操作次数。
>
> 接下来 M 行，每行包含一个操作命令，操作命令为 `push x`，`pop`，`empty`，`query` 中的一种。
>
> #### 输出格式
>
> 对于每个 `empty` 和 `query` 操作都要输出一个查询结果，每个结果占一行。
>
> 其中，`empty` 操作的查询结果为 `YES` 或 `NO`，`query` 操作的查询结果为一个整数，表示栈顶元素的值。
>
> #### 数据范围
>
> 1≤M≤100000
> 1≤x≤10^9
> 所有操作保证合法。
>
> #### 输入样例：
>
> ```
> 10
> push 5
> query
> push 6
> pop
> query
> pop
> empty
> push 4
> query
> empty
> ```
>
> #### 输出样例：
>
> ```
> 5
> 5
> YES
> 4
> NO
> ```

```java
import java.util.Scanner;

public class Main {
    static int N = (int)1e5 + 10;
    static int m;
    static int stk[] = new int[N];
    static int tt;
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        m = sc.nextInt();
        while (m -- != 0){
            int x;
            String op = sc.next();
            if (op.equals("push")){
                x = sc.nextInt();
                stk[++ tt] = x;
            }
            else if (op.equals("pop")) tt --;
            else if (op.equals("empty")) System.out.println(tt != 0 ? "NO" : "YES");
            else System.out.println(stk[tt]);
        }
        sc.close();
    }
}
```

Java里Stack的用法

栈是Vector的一个子类，它实现了一个标准的后进先出的栈。

```java
import java.util.EmptyStackException;
import java.util.Stack;

public class Main {
    public static void main(String[] args) {
        Stack<Integer> stack = new Stack<>();

        System.out.println("stack: " + stack);

        showpush(stack, 42);
        showpush(stack, 66);
        showpush(stack, 99);

        showpop(stack);
        showpop(stack);
        showpop(stack);

        try {
            showpop(stack);
        } catch (EmptyStackException e) {
            System.out.println("empty stack");
        }
    }

    private static void showpush(Stack<Integer> stack, int a){
        stack.push(new Integer(a));
        System.out.println("push(" + a + ")");
        System.out.println("stack: " + stack);
    }

    private static void showpop(Stack<Integer> stack){
        System.out.print("pop -> ");
        Integer a = stack.pop();
        System.out.println(a);
        System.out.println("stack: " + stack);
    }
}

//        stack: []
//        push(42)
//        stack: [42]
//        push(66)
//        stack: [42, 66]
//        push(99)
//        stack: [42, 66, 99]
//        pop -> 99
//        stack: [42, 66]
//        pop -> 66
//        stack: [42]
//        pop -> 42
//        stack: []
//        pop -> empty stack
```

----

#### 队列：

> 实现一个队列，队列初始为空，支持四种操作：
>
> 1. `push x` – 向队尾插入一个数 x；
> 2. `pop` – 从队头弹出一个数；
> 3. `empty` – 判断队列是否为空；
> 4. `query` – 查询队头元素。
>
> 现在要对队列进行 M 个操作，其中的每个操作 3 和操作 4 都要输出相应的结果。
>
> #### 输入格式
>
> 第一行包含整数 M，表示操作次数。
>
> 接下来 M 行，每行包含一个操作命令，操作命令为 `push x`，`pop`，`empty`，`query` 中的一种。
>
> #### 输出格式
>
> 对于每个 `empty` 和 `query` 操作都要输出一个查询结果，每个结果占一行。
>
> 其中，`empty` 操作的查询结果为 `YES` 或 `NO`，`query` 操作的查询结果为一个整数，表示队头元素的值。
>
> #### 数据范围
>
> 1≤M≤100000
> 1≤x≤10^9
> 所有操作保证合法。
>
> #### 输入样例：
>
> ```
> 10
> push 6
> empty
> query
> pop
> empty
> push 3
> push 4
> pop
> query
> push 6
> ```
>
> #### 输出样例：
>
> ```
> NO
> 6
> YES
> 4
> ```

```java
import java.util.Scanner;

public class Main {
    static int N = (int)1e5 + 10;
    static int m;
    static int q[] = new int[N];
    static int hh,tt = -1;//hh队头,tt队尾
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        m = sc.nextInt();
        while (m -- != 0){
            int x;
            String op = sc.next();
            if (op.equals("push")){
                x = sc.nextInt();
                q[++ tt] = x;
            }
            else if (op.equals("pop")) hh ++;
            else if (op.equals("empty")) System.out.println(hh <= tt ? "NO" : "YES");
            else System.out.println(q[hh]);
        }
        sc.close();
    }
}
```

------

Java里Queue的用法

LinkedList类实现了Queue接口，因此我们可以把LinkedList当成Queue来用

```java
import java.util.LinkedList;
import java.util.Queue;

public class Main {
    public static void main(String[] args) {
        Queue<Integer> queue = new LinkedList<>();
        //add()和remove()方法在失败的时候会抛出异常(不推荐)
        //添加元素
        queue.offer(1);
        queue.offer(2);
        queue.offer(3);
        queue.offer(4);
        queue.offer(5);

        for(int q : queue){
            System.out.println(q);
        }
        System.out.println("===");
//        1
//        2
//        3
//        4
//        5
//        ===

        System.out.println("poll=" + queue.poll()); //返回第一个元素，并在队列中删除
        for(int q : queue){
            System.out.println(q);
        }
        System.out.println("===");
//        poll=1
//        2
//        3
//        4
//        5
//        ===

        System.out.println("element=" + queue.element()); //返回第一个元素
        for(int q : queue){
            System.out.println(q);
        }
        System.out.println("===");
//        element=2
//        2
//        3
//        4
//        5
//        ===


        System.out.println("peek=" + queue.peek()); //返回第一个元素
        for(int q : queue){
            System.out.println(q);
        }
//        peek=2
//        2
//        3
//        4
//        5

    }
}
```
