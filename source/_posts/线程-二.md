---
title: 线程(二)
date: 2022-01-9 19:23:12
tags: [线程,多线程]
categories: java
---

## 第四章	线程状态

------------

### 4.1线程状态概述

当线程被创建并启用后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。

在线程的生命周期中，API中`java.lang.Thread.State`这个枚举中给出了六种线程状态：

![20210810174734](https://tonkyshan.cn/img/202202281838147.png)

![20210810174638](https://tonkyshan.cn/img/202202281838281.png)

---

### 4.2Timed Waiting(计时等待)

**倒计时**

```java
package com.indi.demo05.Thread;

public class Demo04Sleep {
    public static void main(String[] args) {
        //模拟秒表
        for (int i = 1; i <= 60; i++) {
            System.out.println(i);
            //使用Thread类的sleep方法让程序睡眠1秒钟
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

    }
}
```

* 进入TIMED_WAITING状态的一种常见情形是调用sleep方法，单独的线程也可以调用，不一定非要有协作关系。
* 为了让其他的线程有机会执行，可以将Thread.sleep()的调用**放在线程run()之内**。这样才能保证该线程执行过程中会睡眠。
* sleep与锁无关，线程睡眠到期自动苏醒，并返回到Runnable(可运行)状态。

> tips：sleep()中指定的时间是线程不会运行的最短时间。因此，sleep()方法不能保证该线程睡眠到期后就开始立刻执行。

Timed Waiting线程状态图：

![20210810174841](https://tonkyshan.cn/img/202202281838013.png)

---

### 4.3BLOCKED(锁阻塞)

Blocked状态在API中的介绍为：一个正在阻塞等待一个监视器锁(锁对象)的线程处于这一状态。

如，线程A与线程B代码中使用同一锁，如果线程A获取到锁，线程A进入到Runnable状态，那么线程B就进入到Blocked锁阻塞状态。

这是由Runnable状态进入Blocked状态。除此Waiting以及Time Waiting状态也会在某种情况下进入阻塞状态。

![20210810175943](https://tonkyshan.cn/img/202202281838007.png)

---

### 4.4Waiting(无限等待)

Waiting状态在API中介绍为：一个正在无限期等待另一个线程执行一个特别的(唤醒)动作的线程处于这一状态。

Runnable---wait()--->Waiting---notify()--->Runnable

**等待唤醒案例:线程之间的通信**
        创建一个顾客线程(消费者):告知老板要的包子的种类和数量,调用wait方法,放弃cpu的执行,进入到WAITING状态(无限等待)

​        创建一个老板线程(生产者):花了5秒做包子,做好包子之后,调用notify方法,唤醒顾客吃包子

注意:
       顾客和老板线程必须使用同步代码块包裹起来,保证等待和唤醒只能有一个在执行

​       同步使用的锁对象必须保证唯—
​       只有锁对象才能调用wait和notify方法

Obejct类中的方法
void wait()
         在其他线程调用此对象的notify()方法或notifyAll()方法前，导致当前线程等待。

void notify()
         唤醒在此对象监视器上等待的单个线程。

​         会继续执行wait方法之后的代码。

```java
package com.indi.demo10WaitAndNotify;

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class Demo01WaitAndNotify {
    public static void main(String[] args) {
        Object obj =new Object();
        new Thread(){
            @Override
            public void run() {
                while (true){
                    synchronized (obj){
                        System.out.println("告知老板要的包子的种类和数量");
                        try {
                            obj.wait();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        //唤醒之后的代码
                        System.out.println("开吃！");
                        System.out.println("----------------------------");
                    }
                }
            }
        }.start();
          new Thread(){
              @Override
              public void run() {
                  while (true){
                      try {
                          Thread.sleep(5000);
                      } catch (InterruptedException e) {
                          e.printStackTrace();
                      }
                      synchronized (obj){
                          System.out.println("老板5秒钟之后做好包子，告知顾客，可以吃包子了");
                          obj.notify();
                      }
                  }
              }
          }.start();
    }
}
```

**进入到Timelwaiting (计时等待)有两种方式**

* 使用sleep(Long m)方法,在毫秒值结束之后,线程睡醒进入到RunnablLe/BLocked状态
* 使用wait(Long m)方法, wait方法如果在毫秒值结束之后,还没有被notify唤醒,就会自动醒来，线程睡醒进入到Runmable/Blocked状态

**唤醒的方法:**

* void notify()：唤醒在此对象监视器上等待的单个线程。
* void notifyAll()：唤醒在此对象监视器上等待的所有线程。

```java
package com.indi.demo10WaitAndNotify;

public class Demo02WaitAndNotify {
    public static void main(String[] args) {
        Object obj =new Object();
        new Thread(){
            @Override
            public void run() {
                synchronized (obj){
                    System.out.println("顾客1告知老板要的包子的种类和数量");
                    try {
                        obj.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    //唤醒之后的代码
                    System.out.println("顾客1开吃！");
                    System.out.println("----------------------------");
                }
           }
        }.start();

        new Thread(){
            @Override
            public void run() {
                synchronized (obj){
                    System.out.println("顾客2告知老板要的包子的种类和数量");
                    try {
                        obj.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    //唤醒之后的代码
                    System.out.println("顾客2开吃！");
                    System.out.println("----------------------------");
                }
            }
        }.start();

        new Thread(){
            @Override
            public void run() {
                while (true){
                    try {
                        Thread.sleep(5000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    synchronized (obj){
                        System.out.println("老板5秒钟之后做好包子，告知顾客，可以吃包子了");
//                        obj.notify();//如果有多个等待线程，随机唤醒一个
                          obj.notifyAll();//全部唤醒
                    }
                }
            }
        }.start();
    }
}
```

---

## 第五章	等待唤醒机制

-------

### 5.1线程间通讯

**概念：**多个线程在处理同一个资源，但是处理的动作(线程的任务)却不相同。

比如：线程A用来生产商品，线程B用来购买商品，商品可以理解为同一资源，线程A与线程B处理的动作，一个是生产，一个是消费，那么线程A与线程B之间就存在线程通信问题。

**为什么要处理线程间通信：**

多个线程并发执行时，在默认情况下CPU是随机切换线程的，当我们需要多个线程来共同完成一件任务时，并且我们希望他们有规律的执行，那么多线程之间需要一些协调通信，以此来帮我们达到多线程共同操作一份数据。

**如何保证线程间通信有效利用资源：**

多个线程在处理同一个资源，并且任务不同时，需要线程通信来帮助解决线程之间对同一个变量的使用或操作。就是多个线程在操作同一份数据时，避免对同一共享变量的争夺。也就是我们需要通过一定的手段使各个线程能有效的利用资源。而这种手段即--**等待唤醒机制**。

---

### 5.2等待唤醒机制

**什么是等待唤醒机制**
这是多个线程间的一种**协作**机制。谈到线程我们经常想到的是线程间的**竞争 ( race )**，比如去争夺锁，但这并不是故事的全部，线程间也会有协作机制。

就是在一个线程进行了规定操作后，就进入等待状态 ( **wait()**)，等待其他线程执行完他们的指定代码过后再将其唤醒( **notify()**) ;在有多个线程进行等待时，如果需要，可以使用**notifyAll()**来唤醒所有的等待线程。

wait/notify 就是线程间的一种协作机制。

**等待唤醒中的方法**
等待唤醒机制就是用于解决线程间通信的问题的，使用到的3个方法的含义如下︰

* wait :线程不再活动，不再参与调度，进入wait set中，因此不会浪费CPU资源，也不会去竞争锁了，这时的线程状态即是WAITING。它还要等着别的线程执行一个**特别的动作**，也即是"**通知( notify )** "在这个对象上等待的线程队wait set中释放出来，重新进入到调度队列( ready queue )中
* notify :则选取所通知对象的wait set中的一个线程释放;唤醒等待时间最长的那个线程。
* notifyAll:则释放所通知对象的wait set 上的全部线程。

> tips：哪怕只通知了一个等待的线程，被通知线程也不能立即恢复执行，因为它当初中断的地方是在同步块内，而此刻它已经不持有锁，所以她需要再次尝试去获取锁(很可能面临其它线程的竞争），成功后才能在当初调用wait方法之后的地方恢复执行。
>
> 总结：
>
> * 如果能获取锁，线程就从WAITING状态变成RUNNABLE状态
> * 否则，总wait set 出来，又进入entry set，线程就从WAITING状态又变成BLOCKED状态

**调用wait和notify方法需要注意的细节**

* wait方法与notify方法必须要由同一个锁对象调用。因为∶对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait方法后的线程。
* wait方法与notify方法是属于Object类的方法的。因为︰锁对象可以是任意对象，而任意对象的所属类都是继承了Object类的。
* wait方法与notify方法必须要在同步代码块或者是同步函数中使用。因为∶必须要通过锁对象调用这2个方法。

---

### 5.3生产者与消费者问题

```java
package com.indi.demo11case;

public class Demo01WaitAndNotify {
    public static void main(String[] args) {
     shangPin sp=new shangPin();
     new ThreadA(sp).start();
     new ThreadB(sp).start();
    }
}
```

```java
package com.indi.demo11case;

public class shangPin {
    String goods;
    String box;
    boolean flag =false;
}
```

```java
package com.indi.demo11case;

public class ThreadA extends Thread{
    private shangPin sp;
    public ThreadA(shangPin sp){
        this.sp=sp;
    }

    @Override
    public void run() {
        int count=0;
        while (true){
            synchronized (sp){
                if (sp.flag=true){
                    try {
                        sp.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                if (count%2==0){
                    sp.goods="aj1";
                    sp.box="塑料盒";
                }else {
                    sp.goods="af1";
                    sp.box="纸盒";
                }
                count++;
                System.out.println("ThreadA正在生产"+sp.goods+sp.box);
                try {
                    Thread.sleep(3000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                sp.flag=true;
                sp.notify();
                System.out.println("ThreadA已经生产好了"+sp.goods+sp.box+"ThreadB可以开始购买了");
            }
        }
    }
}
```

```java
package com.indi.demo11case;

public class ThreadB extends Thread {
    private shangPin sp;
    public ThreadB(shangPin sp){
        this.sp=sp;
    }

    @Override
    public void run() {
        while (true){
            synchronized (sp){
                if (sp.flag=false){
                    try {
                        sp.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                System.out.println("ThreadB正在购买："+sp.goods+sp.box+"商品");
                sp.flag=false;
                sp.notify();
                System.out.println("ThreadB已经把："+sp.goods+sp.box+"商品购买完了，ThreadA开始生产商品");
                System.out.println("----------------------------------------------------------------");
            }
        }
    }
}
```

---------

## 第六章	线程池

--------

### 6.1线程池思想概述

![20210810212906](https://tonkyshan.cn/img/202202281732845.png)

我们使用线程的时候就去创建一个线程，这样实现起来非常简便，但是就会有一个问题:

如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。

那么有没有一种办法使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务?

在Java中可以通过线程池来达到这样的效果。

---------

### 6.2线程池概念

* **线程池**：其实就是一个容纳多个线程的容器，其中的线程可以重复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。

![20210810214141](https://tonkyshan.cn/img/202202281838133.png)

线程池工作原理图：

![20210810214223](https://tonkyshan.cn/img/202202281838386.png)

合理利用线程池能够带来三个好处：

* 降低资源消耗。减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。
* 提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。
* 提高线程的可管理性。可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。

---------

### 6.3线程池的使用

Java里面线程池的顶级接口是`java.util.concurrent.Executor`，但是严格意义上讲`Executor`并不是一个线程池，而是一个执行线程的工具。真正的线程池接口是`java.util.concurrent.ExecutorService`。

要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置线程池不是较优的，因此在`java.util.concurrent.Executors`线程工厂类里面提供了一些静态工厂，生成一些常用的线程池。官方建议使用Executors工程类来创建线程池对象。

Executors类中有创建线程池的方法如下：

* `public static ExecutorService newFixedThreadPool(int nThreads)`：返回线程池对象。(创建的是有界线程池，也就是池中的线程个数可以指定最大数量)

获取到了一个线程池ExecutorService对象，那么怎么使用呢，在这里定义了一个使用线程池对象的方法如下:

* `public Future<?> submit(Runnable task)`：获取线程池中的某一个线程对象，并执行。

> Future接口：用来记录线程任务执行完毕后产生的结果。线程池创建与使用。

使用线程池中线程对象的步骤：

1.创建线程池对象。

2.创建Runnable接口子类对象。(task)

3.提交Runnable接口子类对象。(take task)

4.关闭线程池(一般不做)。

```java
package com.indi.demo12ThreadPool;

import java.util.concurrent.Executor;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class Demo01ThreadPool {
    public static void main(String[] args) {
        ExecutorService executorService = Executors.newFixedThreadPool(2);
        executorService.submit(new RunnableImpl());
        executorService.submit(new RunnableImpl());
        executorService.submit(new RunnableImpl());
        executorService.shutdown();//不建议执行
    }
}
```

```java
package com.indi.demo12ThreadPool;

public class RunnableImpl implements Runnable {
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName()+"创建了一个新的线程执行");
    }
}
```
