<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<script src='https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js'></script>

    <meta name="author" content="ShanTianQi">





<title>Git | ShanTianQi&#39;s Blog</title>



    <link rel="icon" href="../../../../favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="../../../../css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="../../../../js/script.js"></script>
    
    <script src="../../../../js/tocbot.min.js"></script>
    



    
    
        
    


<!-- hexo injector head_end start --><script type="module" src="https://cdn.jsdelivr.net/npm/mermaid@7.1.2/dist/mermaid.esm.min.mjs">
    mermaid.initialize(
      startOnLoad: true,
    );
    </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.0.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            pagebody.classList.add('dark-theme');
            // mobile
            document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            // if (isDark) {
            //     pagebody.classList.add('dark-theme');
            //     // mobile
            //     document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            // } else {
            //     pagebody.classList.remove('dark-theme');
            //     // mobile
            //     document.getElementById("mobile-toggle-theme").innerText = "· Light"
            // }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <!-- <div class="navbar-header header-logo"><a href="/">ShanTianQi&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="../../../../archives">Posts</a>
                
                    <a class="menu-item" href="../../../../category">Categories</a>
                
                    <a class="menu-item" href="../../../../tag">Tags</a>
                
                    <a class="menu-item" href="../../../../about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div> -->
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <!-- <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">ShanTianQi&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="../../../../archives">Posts</a>
                
                    <a class="menu-item" href="../../../../category">Categories</a>
                
                    <a class="menu-item" href="../../../../tag">Tags</a>
                
                    <a class="menu-item" href="../../../../about">About</a>
                
            </div>
        </div> -->
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">Git</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">ShanTianQi</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">July 2, 2022&nbsp;&nbsp;10:45:15</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="../../../../categories/Git/">Git</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><hr>
<p>git本质上来讲其实是树状结构，但很多地方讲的时候只讲命令及其用法，显得就很难理解。</p>
<p>git是版本管理工具，有时候会迭代，会更新，会回滚，所以就会有这样一种工具</p>
<p>git最好的一个特点也是可以多人合作</p>
<h3 id="git基本概念"><a href="#git基本概念" class="headerlink" title="git基本概念"></a>git基本概念</h3><ul>
<li>工作区：仓库的目录。工作区是独立于各个分支的。</li>
<li>暂存区：数据暂时存放的区域，类似于工作区写入版本库前的缓存区。暂存区是独立于各个分支的。</li>
<li>版本库：存放所有已经提交到本地仓库的代码版本</li>
<li>版本结构：树结构，树中每个节点代表一个代码版本。</li>
</ul>
<h3 id="git-常用命令"><a href="#git-常用命令" class="headerlink" title="git 常用命令"></a>git 常用命令</h3><pre class="line-numbers language-none"><code class="language-none">git config -- global user.name xxx
git config --global user.email xxxxxx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>创建一个文件夹里</p>
<p><code>git init</code> 创建一个仓库</p>
<p><code>git status</code> 查看状态</p>
<pre class="line-numbers language-none"><code class="language-none">git commit -m &quot;填写你的注释&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><code>git diff</code> 工作区文件和暂存区文件的区别</p>
<p><code>git rm --cached XX</code>：将文件从仓库索引目录中删掉</p>
<p><code>git restore --staged</code> 将文件从暂存区撤出，但不会撤销文件的更改<br><code>git resore</code> 将不在暂存区的文件撤销更改 (不仅可以把修改回滚掉，删除也可以)</p>
<pre class="line-numbers language-none"><code class="language-none">git log&#96;查看当前分支的所有版本：&#96;git log --pretty&#x3D;online<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><code>git reflog</code>：查看HEAD指针的移动历史（包括被回滚的版本）</p>
<p>reflog 和log 还是有不同的地方的– reflog记录你所有移动的记录，log记录你从源头到head的记录</p>
<ul>
<li><code>git reset --hard HEAD^ </code>或 <code>git reset --hard HEAD~</code>：将代码库回滚到上一个版本<ul>
<li>git reset –hard HEAD^^：往上回滚两次，以此类推、</li>
<li>git reset –hard HEAD~100：往上回滚100个版本</li>
<li>git reset –hard 版本号：回滚到某一特定版本</li>
</ul>
</li>
<li><code>git push -u</code> (第一次需要-u以后不需要)：将当前分支推送到远程仓库<ul>
<li><code>git push origin branch_name</code>：将本地的某个分支推送到远程仓库</li>
</ul>
</li>
</ul>
<p><code>git remote add origin git@git.gitee.com:xxx/XXX.git</code>：将本地仓库关联到远程仓库(后面那一串就是仓库地址)</p>
<p><code>git checkout -b branch_name</code>：创建并切换到branch_name这个分支</p>
<p><code>git branch</code>：查看所有分支和当前所处分支<br><code>git checkout branch_name</code>：切换到branch_name这个分支<br><code>git merge branch_name</code>：将分支branch_name合并到当前分支上<br><code>git branch -d branch_name</code>：删除本地仓库的branch_name分支</p>
<p><code>git push --set-upstream origin branch_name</code>：设置本地的branch_name分支对应远程仓库的branch_name分支<br><code>git push -d origin branch_name</code>：删除远程仓库的branch_name分支</p>
<p><code>git branch --set-upstream-to=origin/branch_name1 branch_name2</code>：将远程的branch_name1分支与本地的branch_name2分支对应<br><code>git checkout -t origin/branch_name</code> 将远程的branch_name分支拉取到本地</p>
<hr>
<h3 id="关于stash"><a href="#关于stash" class="headerlink" title="关于stash"></a>关于stash</h3><p><code>git stash</code>：将工作区和暂存区中尚未提交的修改存入栈中<br><code>git stash apply</code>：将栈顶存储的修改恢复到当前分支，但不删除栈顶元素<br><code>git stash drop</code>：删除栈顶存储的修改<br><code>git stash pop</code>：将栈顶存储的修改恢复到当前分支，同时删除栈顶元素<br><code>git stash list</code>：查看栈中所有元素</p>
<hr>
<h2 id="Git原理"><a href="#Git原理" class="headerlink" title="Git原理"></a>Git原理</h2><hr>
<blockquote>
<p>本文以一个具体例子结合动图介绍了Git的内部原理，包括Git是什么储存我们的代码和变更历史的、更改一个文件时，Git内部是怎么变化的、Git这样实现的有什么好处等等。<br>通过例子解释清楚上面这张动图，让大家了解Git的内部原理。如果你已经能够看懂这张图了，下面的内容可能对你来说会比较基础。</p>
<p>视频链接：<br><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av77252063">https://www.bilibili.com/video/av77252063</a><br>PPT 链接：<br><a href="https://link.zhihu.com/?target=https://www.lzane.com/slide/git-under-the-hood">https://www.lzane.com/slide/git-under-the-hood</a></p>
</blockquote>
<p><video src="https://cdn.jsdelivr.net/gh/EchoTo/blog-img@main/img/be72a612-2397-11eb-a5d4-3e7c04448a0a.mp4"></video></p>
<p><strong>前言</strong></p>
<p>近几年技术发展十分迅猛，让部分同学养成了一种学习知识停留在表面，只会调用一些指令的习惯。我们时常有一种“我会用这个技术、这个框架”的错觉，等到真正遇到问题，才发现事情没有那么简单。</p>
<p>而Git也是一个大部分人都知道如何去使用它，知道有哪些命令，却只有少部分人知道具体原理的东西。了解一些底层的东西，可以更好的帮你理清思路，知道你真正在操作什么，不会迷失在Git大量的指令和参数上面。</p>
<h3 id="Git是怎么储存信息的"><a href="#Git是怎么储存信息的" class="headerlink" title="Git是怎么储存信息的"></a><strong>Git是怎么储存信息的</strong></h3><p>这里会用一个简单的例子让大家直观感受一下git是怎么储存信息的。</p>
<p>首先我们先创建两个文件</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">$ git init
$ echo '111' > a.txt
$ echo '222' > b.txt
$ git add *.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>Git会将整个数据库储存在<code>.git/</code>目录下，如果你此时去查看<code>.git/objects</code>目录，你会发现仓库里面多了两个object。</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">$ tree .git/objects
.git/objects
├── 58
│   └── c9bdf9d017fcd178dc8c073cbfcbb7ff240d6c
├── c2
│   └── 00906efd24ec5e783bee7f23b5d7c941b0c12c
├── info
└── pack<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>好奇的我们来看一下里面存的是什么东西</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">$ cat .git/objects/58/c9bdf9d017fcd178dc8c073cbfcbb7ff240d6c
xKOR0a044K%<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>怎么是一串乱码？这是因为Git将信息压缩成<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:96631135%7D">二进制文件</a>。但是不用担心，因为Git也提供了一个能够帮助你探索它的api <code>git cat-file [-t] [-p]</code>， <code>-t</code>可以查看object的类型，<code>-p</code>可以查看object储存的具体内容。</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">$ git cat-file -t 58c9
blob
$ git cat-file -p 58c9
111<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以发现这个object是一个blob类型的节点，他的内容是111，也就是说这个object储存着a.txt文件的内容。</p>
<p>这里我们遇到第一种Git object，<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=blob%E7%B1%BB%E5%9E%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:96631135%7D">blob类型</a>，它只储存的是一个文件的内容，不包括文件名等其他信息。然后将这些信息经过SHA1哈希算法得到对应的<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E5%93%88%E5%B8%8C%E5%80%BC&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:96631135%7D">哈希值</a><br>58c9bdf9d017fcd178dc8c073cbfcbb7ff240d6c，作为这个object在Git仓库中的唯一身份证。</p>
<p>也就是说，我们此时的Git仓库是这样子的：</p>
<p><img src="https://pic3.zhimg.com/80/v2-00d6bbea76593d4543b3da5695f9237e_720w.jpg" alt="img"></p>
<p>我们继续探索，我们创建一个commit。</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">$ git commit -am '[+] init'
$ tree .git/objects
.git/objects
├── 0c
│   └── 96bfc59d0f02317d002ebbf8318f46c7e47ab2
├── 4c
│   └── aaa1a9ae0b274fba9e3675f9ef071616e5b209
...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>我们会发现当我们commit完成之后，Git仓库里面多出来两个object。同样使用<code>cat-file</code>命令，我们看看它们分别是什么类型以及具体的内容是什么。</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">$ git cat-file -t 4caaa1
tree
$ git cat-file -p 4caaa1
100644 blob 58c9bdf9d017fcd178dc8c0...     a.txt
100644 blob c200906efd24ec5e783bee7...    b.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这里我们遇到了第二种Git object类型——tree，它将当前的目录结构打了一个快照。从它储存的内容来看可以发现它储存了一个目录结构（类似于文件夹），以及每一个文件（或者子文件夹）的权限、类型、对应的身份证（SHA1值）、以及文件名。</p>
<p>此时的Git仓库是这样的：</p>
<p><img src="https://pic3.zhimg.com/80/v2-fdf4ccc9ec7bf2e64d35225b36823a02_720w.jpg" alt="img"></p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">$ git cat-file -t 0c96bf
commit
$ git cat-file -p 0c96bf
tree 4caaa1a9ae0b274fba9e3675f9ef071616e5b209
author lzane 李泽帆  1573302343 +0800
committer lzane 李泽帆  1573302343 +0800
[+] init<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>接着我们发现了第三种Git object类型——commit，它储存的是一个提交的信息，包括对应目录结构的<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E5%BF%AB%E7%85%A7tree&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:96631135%7D">快照tree</a>的哈希值，上一个提交的哈希值（这里由于是第一个提交，所以没有父节点。在一个merge提交中还会出现多个父节点），提交的作者以及提交的具体时间，最后是该提交的信息。</p>
<p>此时我们去看Git仓库是这样的：</p>
<p><img src="https://pic4.zhimg.com/80/v2-000426d3672ed834ed9594844fef5d47_720w.jpg" alt="img"></p>
<p>到这里我们就知道Git是怎么储存一个提交的信息的了，那有同学就会问，我们平常接触的<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E5%88%86%E6%94%AF%E4%BF%A1%E6%81%AF&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:96631135%7D">分支信息</a>储存在哪里呢？</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">$ cat .git/HEAD
ref: refs/heads/master

$ cat .git/refs/heads/master
0c96bfc59d0f02317d002ebbf8318f46c7e47ab2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在Git仓库里面，HEAD、分支、普通的Tag可以简单的理解成是一个指针，指向对应commit的SHA1值。</p>
<p><img src="https://pic1.zhimg.com/80/v2-1cbdf1cf24c0c0b3c0a6e9a7429bb070_720w.jpg" alt="img"></p>
<p>其实还有第四种Git object，类型是tag，在添加含附注的tag（<code>git tag -a</code>）的时候会新建，这里不详细介绍，有兴趣的朋友按照上文中的方法可以深入探究。</p>
<p>至此我们知道了Git是什么储存一个文件的内容、目录结构、commit信息和分支的。<strong>其本质上是一个key-value的数据库加上默克尔树形成的有向无环图（DAG）</strong>。这里可以蹭一下区块链的热度，区块链的数据结构也使用了默克尔树。</p>
<h3 id="Git的三个分区"><a href="#Git的三个分区" class="headerlink" title="Git的三个分区"></a><strong>Git的三个分区</strong></h3><p>接下来我们来看一下Git的三个分区（工作目录、Index <a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E7%B4%A2%E5%BC%95%E5%8C%BA%E5%9F%9F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:96631135%7D">索引区域</a>、Git仓库），以及Git变更记录是怎么形成的。了解这三个分区和Git链的内部原理之后可以对Git的众多指令有一个“可视化”的理解，不会再经常搞混。</p>
<p>接着上面的例子，目前的仓库状态如下：</p>
<p><img src="https://pic1.zhimg.com/80/v2-71aa7d6613b4b9efbee48415f1369590_720w.jpg" alt="img"></p>
<p>这里有三个区域，他们所储存的信息分别是：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:96631135%7D">工作目录</a> （ working directory ）：操作系统上的文件，所有代码开发编辑都在这上面完成。</li>
<li>索引（ index or staging area ）：可以理解为一个暂存区域，这里面的代码会在下一次commit被提交到Git仓库。</li>
<li>Git仓库（ git repository ）：由Git object记录着每一次提交的快照，以及<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E9%93%BE%E5%BC%8F%E7%BB%93%E6%9E%84&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:96631135%7D">链式结构</a>记录的提交变更历史。</li>
</ul>
<p>我们来看一下更新一个文件的内容这个过程会发生什么事。</p>
<p><img src="https://tonkyshan.cn/img/v2-23bbe72110019b5dd538d61a11874cd5_b.gif" alt="v2-23bbe72110019b5dd538d61a11874cd5_b"></p>
<p>运行<code>echo &quot;333&quot; &gt; a.txt</code>将a.txt的内容从111修改成333，此时如上图可以看到，此时索引区域和git仓库没有任何变化。</p>
<p><img src="https://tonkyshan.cn/img/1.gif" alt="1"></p>
<p>运行<code>git add a.txt</code>将a.txt加入到索引区域，此时如上图所示，git在仓库里面新建了一个blob object，储存了新的文件内容。并且更新了索引将a.txt指向了新建的<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=blob+object&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:96631135%7D">blob object</a>。</p>
<p><img src="https://tonkyshan.cn/img/2.gif" alt="2"></p>
<p>运行<code>git commit -m &#39;update&#39;</code>提交这次修改。如上图所示</p>
<ol>
<li>Git首先根据当前的索引生产一个<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=tree+object&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:96631135%7D">tree object</a>，充当新提交的一个快照。</li>
<li>创建一个新的commit object，将这次commit的信息储存起来，并且parent指向上一个commit，组成一条链记录变更历史。</li>
<li>将master分支的指针移到新的<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=commit%E7%BB%93%E7%82%B9&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:96631135%7D">commit结点</a>。</li>
</ol>
<p>至此我们知道了Git的三个分区分别是什么以及他们的作用，以及历史链是怎么被建立起来的。<strong>基本上Git的大部分指令就是在操作这三个分区以及这条链。</strong>可以尝试的思考一下git的各种命令，试一下你能不能够在上图将它们<strong>“可视化”</strong>出来，这个很重要，建议尝试一下。</p>
<p>如果不能很好的将日常使用的指令“可视化”出来，推荐阅读 <a href="https://link.zhihu.com/?target=https://marklodato.github.io/visual-git-guide/index-zh-cn.html">图解Git</a></p>
<h3 id="一些有趣的问题"><a href="#一些有趣的问题" class="headerlink" title="一些有趣的问题"></a><strong>一些有趣的问题</strong></h3><p>有兴趣的同学可以继续阅读，这部分不是文章的主要内容</p>
<p><strong>问题1：为什么要把文件的权限和文件名储存在tree object里面而不是blob object呢？</strong></p>
<p>想象一下修改一个文件的命名。</p>
<p>如果将文件名保存在blob里面，那么Git只能多复制一份原始内容形成一个新的blob object。而Git的实现方法只需要创建一个新的tree object将对应的文件名更改成新的即可，原本的blob object可以复用，节约了空间。</p>
<p><strong>问题2：每次commit，Git储存的是全新的文件快照还是储存文件的变更部分？</strong></p>
<p>由上面的例子我们可以看到，Git储存的是全新的文件快照，而不是文件的变更记录。也就是说，就算你只是在文件中添加一行，Git也会新建一个全新的blob object。那这样子是不是很浪费空间呢?</p>
<p>这其实是Git在空间和时间上的一个取舍，思考一下你要checkout一个commit，或对比两个commit之间的差异。如果Git储存的是问卷的变更部分，那么为了拿到一个commit的内容，Git都只能从第一个commit开始，然后一直计算变更，直到目标commit，这会花费很长时间。而相反，Git采用的储存全新文件快照的方法能使这个操作变得很快，直接从快照里面拿取内容就行了。</p>
<p>当然，在涉及网络传输或者Git仓库真的体积很大的时候，Git会有垃圾回收机制gc，不仅会清除无用的object，还会把已有的相似object打包压缩。</p>
<p><strong>问题3：Git怎么保证历史记录不可篡改？</strong></p>
<p>通过<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=SHA1%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:96631135%7D">SHA1哈希算法</a>和哈系树来保证。假设你偷偷修改了历史变更记录上一个文件的内容，那么这个问卷的blob object的SHA1哈希值就变了，与之相关的tree object的SHA1也需要改变，commit的SHA1也要变，这个commit之后的所有commit SHA1值也要跟着改变。又由于Git是分布式系统，即所有人都有一份完整历史的Git仓库，所以所有人都能很轻松的发现存在问题。</p>
<p>希望大家读完有所收获，下一篇文章会写一些我日常工作中觉得比较实用的Git技巧、经常被问到的问题、以及发生一些事故时的处理方法。</p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>ShanTianQi</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="https://tonkyshan.cn/2022/07/02/Git/">https://tonkyshan.cn/2022/07/02/Git/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="../../../../tags/Git/"># Git</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="../../25/SQL%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8%E6%B5%85%E6%9E%90-%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/">SQL查询优化器浅析 | 青训营笔记</a>
            
            
            <a class="next" rel="next" href="../../../04/13/Maven/">Maven</a>
            
        </section>


    </article>
</div>

            </div>
            <!-- <!--<footer id="footer" class="footer">
    <div class="copyright">
        <span>© ShanTianQi | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>
 -->
    </div>
</body>

</html>